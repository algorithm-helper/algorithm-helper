[
    {
        "category": "data-structures",
        "title": "Data Structures",
        "url": "/categories/data-structures",
        "topics": [
            {
                "topic": "lists",
                "title": "Lists",
                "description": "Learn about linear data structures like Linked Lists, Vectors, Stacks, Queues, and Union Find, as well as amortization.",                
                "url": "/lists",
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of linear data structures, terminology and concepts that will be covered in this topic."
                    },
                    {
                        "article": "linked-list",
                        "title": "Linked List",
                        "url": "/linked-list",
                        "description": "Learn about the Linked List, a recursively defined, sequence of Nodes with pointers to the next Nodes in the sequence, and a head pointer."
                    },
                    {
                        "article": "double-ended-linked-list",
                        "title": "Double Ended Linked List",
                        "url": "/double-ended-linked-list",
                        "description": "Learn about the Double Ended Linked List, an augmentation to the Linked List where Nodes have a next and previous pointer."
                    },
                    {
                        "article": "vector-dynamically-resizing-array",
                        "title": "Vector / Dynamically Resizing Array",
                        "url": "/vector-dynamically-resizing-array",
                        "description": "Learn about the Vector / Dynamically Resizing Array, an array-based data structure that allows for the expansion of the size of the array."
                    },
                    {
                        "article": "amortization",
                        "title": "Amortization",
                        "url": "/amortization",
                        "description": "Learn about Amortization, an analysis method for time and space complexity, and its context within data structures and algorithms."
                    },
                    {
                        "article": "stack",
                        "title": "Stack",
                        "url": "/stack",
                        "description": "Learn about the Stack, a fundamental last-in-first-out data structure, and its implementations with both a Linked List and Vector."
                    },
                    {
                        "article": "queue",
                        "title": "Queue",
                        "url": "/queue",
                        "description": "Learn about the Queue, a fundamental first-in-first-out data structure, and its implementations with both a Linked List and Vector."
                    },
                    {
                        "article": "deque-double-ended-queue",
                        "title": "Deque / Double Ended Queue",
                        "url": "/deque-double-ended-queue",
                        "description": "Learn about the Deque / Double Ended Queue, an abstract data structure that supports adding and removing elements from the front and back."                        
                    },
                    {
                        "article": "union-find-disjoint-set",
                        "title": "Union Find / Disjoint Set",
                        "url": "/union-find-disjoint-set",
                        "description": "Learn about the Union Find / Disjoint Set, a data structure used to represent connected components and in the problem of dynamic connectivity."                        
                    },
                    {
                        "article": "iterator-iterable",
                        "title": "Iterator / Iterable",
                        "url": "/iterator-iterable",
                        "description": "Learn about the Iterator / Iterable, an abstract data structure used for traversing a List structure."
                    },
                    {
                        "article": "time-and-space-complexity",
                        "title": "Time and Space Complexity",
                        "url": "/time-and-space-complexity",
                        "description": "Learn about the time and space complexity of fundamental operations between the data structures listed in this topic."
                    }
                ]
            },
            {
                "topic": "trees",
                "title": "Trees",
                "url": "/trees",
                "description": "Learn about using binary and balanced binary search trees to implement Maps/Sets with logarithmic performance.",                
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of tree data structures, terminology and concepts that will be covered in this topic."
                    },
                    {
                        "article": "map-symbol-table",
                        "title": "Map / Symbol Table",
                        "url": "/map-symbol-table",
                        "description": "Learn about the Map / Symbol Table, an abstract data structure for maintaining a collection of (key, value) pairs."
                    },
                    {
                        "article": "set",
                        "title": "Set",
                        "url": "/set",
                        "description": "Learn about the Set, an abstract data structure for maintaining a collection of unique key elements."
                    },
                    {
                        "article": "binary-search-tree",
                        "title": "Binary Search Tree",
                        "url": "/binary-search-tree",
                        "description": "Learn about the Binary Search Tree, a tree data structure that uses binary search for the efficient retrieval of elements."
                    },
                    {
                        "article": "balanaced-binary-search-tree",
                        "title": "Balanced Binary Search Tree",
                        "url": "/balanced-binary-search-tree",
                        "description": "Learn about the Balanced Binary Search Tree, a tree data structure that guarantees logarithmic performance by keeping balanced."
                    },
                    {
                        "article": "2-3-tree",
                        "title": "2-3 Tree",
                        "url": "/2-3-tree",
                        "description": "Learn about the 2-3 Tree, a tree data structure that keeps balance through the mechanism of 2-Nodes and 3-Nodes."
                    },
                    {
                        "article": "red-black-tree",
                        "title": "Red-Black Tree",
                        "url": "/red-black-tree",
                        "description": "Learn about the Red-Black Tree, a tree data structure derived from the 2-3 Tree, that keeps balance using red and black colored Nodes."
                    },
                    {
                        "article": "avl-tree",
                        "title": "AVL Tree",
                        "url": "/avl-tree",
                        "description": "Learn about the AVL Tree, a tree data structure that keeps balance through maintaining balance between the heights of subtrees."
                    },
                    {
                        "article": "heap",
                        "title": "Heap",
                        "url": "/heap",
                        "description": "Learn about the Heap, a tree data structure that represents the tree in a single array, and implementations for Binary Min/Max Heaps."
                    },
                    {
                        "article": "priority-queue",
                        "title": "Priority Queue",
                        "url": "/priority-queue",
                        "description": "Learn about the Priority Queue, a data structure that uses the Heap data structure to allow for efficient retrieval of min/max elements."
                    },
                    {
                        "article": "time-and-space-complexity",
                        "title": "Time and Space Complexity",
                        "url": "/time-and-space-complexity",
                        "description": "Learn about the time and space complexity of fundamental operations between the data structures listed in this topic."
                    }
                ]
            },
            {
                "topic": "hashing",
                "title": "Hashing",
                "url": "/hashing",
                "description": "Learn about using hash functions to implement Maps/Sets, with efficient (constant, amortized) time for all operations.",                
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of data structures that use hashing, terminology and concepts that will be covered in this topic."
                    },
                    {
                        "article": "hash-function",
                        "title": "Hash Function",
                        "url": "/hash-function",
                        "description": "Learn about the Hash Function, a function that enables mapping data of an arbitrary size to data of fixed size."
                    },
                    {
                        "article": "collision-resolution",
                        "title": "Collision Resolution",
                        "url": "/collision-resolution",
                        "description": "Learn about Collision Resolution, the techniques used when dealing with situations where more than one element hash to the same place."
                    },
                    {
                        "article": "simple-uniform-hashing-assumption",
                        "title": "Simple Uniform Hashing Assumption",
                        "url": "/simple-uniform-hashing-assumption",
                        "description": "Learn about the Simple Uniform Hashing Assumption, the basic mathematical assumption that enables the analysis of Hash Tables / Hash Maps."
                    },
                    {
                        "article": "hash-table-hash-map",
                        "title": "Hash Table / Hash Map",
                        "url": "/hash-table-hash-map",
                        "description": "Learn about the Hash Table / Hash Map, and its implementations with Separate Chaining and Linear Probing, that allows for constant time for all operations."
                    },
                    {
                        "article": "hash-set",
                        "title": "Hash Set",
                        "url": "/hash-set",
                        "description": "Learn about the Hash Set, and its use to represent the abstract data structure of a Set, but using hashing to allow for constant time for all operations."
                    },
                    {
                        "article": "time-and-space-complexity",
                        "title": "Time and Space Complexity",
                        "url": "/time-and-space-complexity",
                        "description": "Learn about the time and space complexity of fundamental operations between the data structures listed in this topic."                        
                    }
                ]
            }
        ]
    },
    {
        "category": "algorithms",
        "title": "Algorithms",
        "url": "/categories/algorithms",
        "topics": [
            {
                "topic": "searching",
                "title": "Searching",
                "url": "/searching",
                "description": "Learn about algorithms for searching for elements in arrays efficiently, in logarithmic time and better.",                
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of the fundamental problem of searching, terminology and concepts that will be covered in this topic."
                    },
                    {
                        "article": "binary-search",
                        "title": "Binary Search",
                        "url": "/binary-search",
                        "description": "Learn about Binary Search, a searching algorithm for retrieving elements in a sorted array in logarithmic time."                    
                    },
                    {
                        "article": "ternary-search",
                        "title": "Ternary Search",
                        "url": "/ternary-search",
                        "description": "Learn about Ternary Search, a searching algorithm for finding the min/max element of a unimodal function."
                    },
                    {
                        "article": "jump-search",
                        "title": "Jump Search",
                        "url": "/jump-search",
                        "description": "Learn about Jump Search, a searching algorithm for retrieving elements in a sorted array by taking steps of size sqrt(N)."
                    },
                    {
                        "article": "interpolation-search",
                        "title": "Interpolation Search",
                        "url": "/interpolation-search",
                        "description": "Learn about Interpolation Search, a searching algorithm for retrieving elements in a sorted array with elements uniformly distributed."
                    },
                    {
                        "article": "time-and-space-complexity",
                        "title": "Time and Space Complexity",
                        "url": "/time-and-space-complexity",
                        "description": "Learn about the time and space complexity of fundamental operations between the algorithms listed in this topic."                        
                    }
                ]
            },
            {
                "topic": "sorting",
                "title": "Sorting",
                "url": "/sorting",
                "description": "Learn about the fundamental problem of sorting, and algorithms like Merge Sort, Quick Sort and Heap Sort.",                
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of algorithms for sorting elements in arrays, terminology and concepts that will be covered in this topic."    
                    },
                    {
                        "article": "stability",
                        "title": "Stability",
                        "url": "/stability",
                        "description": "Learn about Stability, which refers to the property of sorting algorithms to be able to keep identical elements in the same final order."
                    },
                    {
                        "article": "in-place",
                        "title": "In-Place",
                        "url": "/in-place",
                        "description": "Learn about In-Place, where refers to the property of sorting algorithms to be able to be performed without the use of auxiliary space."
                    },
                    {
                        "article": "selection-sort",
                        "title": "Selection Sort",
                        "url": "/selection-sort",
                        "description": "Learn about Selection Sort, a sorting algorithm that works by iterating through the array, selecting the minimum element each time."
                    },
                    {
                        "article": "insertion-sort",
                        "title": "Insertion Sort",
                        "url": "/insertion-sort",
                        "description": "Learn about Insertion Sort, a sorting algorithm that works by inserting the next element into the current sorted array."
                    },
                    {
                        "article": "shell-sort",
                        "title": "Shell Sort",
                        "url": "/shell-sort",
                        "description": "Learn about Shell Sort, a sorting algorithm that uses h-sorting, and takes advantage of Insertion Sort's efficiency with nearly sorted arrays."
                    },
                    {
                        "article": "divide-and-conquer",
                        "title": "Divide and Conquer",
                        "url": "/divide-and-conquer",
                        "description": "Learn about Divide and Conquer, an algorithm design paradigm that recursively breaks down a larger problem into easier, smaller, subproblems."
                    },
                    {
                        "article": "merge-sort",
                        "title": "Merge Sort",
                        "url": "/merge-sort",
                        "description": "Learn about Merge Sort, an efficient sorting algorithm that works by recursively breaking down subarrays and merging sorted subarrays."
                    },
                    {
                        "article": "quick-sort",
                        "title": "Quick Sort",
                        "url": "/quick-sort",
                        "description": "Learn about Quick Sort, an efficient sorting algorithm that works by using a pivot and recurively sorting elements to the left and right of the pivot."
                    },
                    {
                        "article": "heap-sort",
                        "title": "Heap Sort",
                        "url": "/heap-sort",
                        "description": "Learn about Heap Sort, an efficient sorting algorithm that works by building a Binary Min Heap out of the elements, and swapping the min element with the last element."
                    },
                    {
                        "article": "bucket-sort",
                        "title": "Bucket Sort",
                        "url": "/bucket-sort",
                        "description": "Learn about Bucket Sort, a sorting algorithm that runs in linear time in the context of sorting integer elements, by moving them to array indices that match the element."
                    },
                    {
                        "article": "radix-sort",
                        "title": "Radix Sort",
                        "url": "/radix-sort",
                        "description": "Learn about Radix Sort, a sorting algorithm that is used to sort integer elements through the use of looking at the least to most significant digits of the elements."
                    },
                    {
                        "article": "comparator-comparable",
                        "title": "Comparator / Comparable",
                        "url": "/comparator-comparable",
                        "description": "Learn about the Comparator / Comparable, an abstract data structure that enables the comparison of two Objects to create more generic sorting algorithms."
                    },
                    {
                        "article": "time-and-space-complexity",
                        "title": "Time and Space Complexity",
                        "url": "/time-and-space-complexity",
                        "description": "Learn about the time and space complexity of fundamental operations between the algorithms listed in this topic."                        
                    }
                ]
            },
            {
                "topic": "shuffling",
                "title": "Shuffling",
                "url": "/shuffling",
                "description": "Learn about algorithms like Fisher-Yates and Sattolo's Algorithm to order elements in arrays uniformly randomly.",                
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of algorithms for the fundamental problem of shuffling, terminology and concepts that will be covered in this topic."
                    },
                    {
                        "article": "fisher-yates-shuffle",
                        "title": "Fisher-Yates Shuffle",
                        "url": "/fisher-yates-shuffle",
                        "description": "Learn about the Fisher-Yates Shuffle, a shuffling algorithm used to uniformly randomly distribute elements within an array."
                    },
                    {
                        "article": "sattolos-algorithm",
                        "title": "Sattolo's Algorithm",
                        "url": "/sattolos-algorithm",
                        "description": "Learn about Sattolo's Algorithm, a shuffling algorithm with the property that elements cannot be shuffled to their initial position."
                    },
                    {
                        "article": "time-and-space-complexity",
                        "title": "Time and Space Complexity",
                        "url": "/time-and-space-complexity",
                        "description": "Learn about the time and space complexity of fundamental operations between the algorithms listed in this topic."                                                
                    }
                ]
            },
            {
                "topic": "graphs",
                "title": "Graphs",
                "url": "/graphs",
                "description": "Learn about algorithms for shortest path finding, minimum spanning trees, topological sorting, cycles and network flow.",                
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of the algorithms used in the context of graph theory, terminology and concepts that will be covered in this topic."
                    },
                    {
                        "article": "undirected-and-directed-graphs",
                        "title": "Undirected and Directed Graphs",
                        "url": "/undirected-and-directed-graphs",
                        "description": "Learn about Undirected and Directed Graphs, two types of graphs that greatly dictate the limitations of certain algorithms used on them."
                    },
                    {
                        "article": "sparse-and-dense-graphs",
                        "title": "Sparse and Dense Graphs",
                        "url": "/sparse-and-dense-graphs",
                        "description": "Learn about Sparse and Dense Graphs, two types of graphs that refer to the property of the number of vertex and edges within the graph."
                    },
                    {
                        "article": "graph-representation",
                        "title": "Graph Representation",
                        "url": "/graph-representation",
                        "description": "Learn about Graph Representation, and the three main implementations using Edge Lists, Vertex Matricies, and Adjacency Lists."
                    },
                    {
                        "article": "path-finding",
                        "title": "Path Finding",
                        "url": "/path-finding",
                        "description": "Learn about Path Finding, the fundamental problem within graphs of being able to find a sequence of edges that go from a starting vertex to ending vertex."
                    },
                    {
                        "article": "depth-first-search",
                        "title": "Depth First Search",
                        "url": "/depth-first-search",
                        "description": "Learn about Depth First Search, a basic graph traversal algorithm with the property of always choosing adjacent vertices to be the next to be traversed."
                    },
                    {
                        "article": "breadth-first-search",
                        "title": "Breadth First Search",
                        "url": "/breadth-first-search",
                        "description": "Learn about Breadth First Search, a basic graph traversal algorithm with the property of always at the same level to be the next to be traversed."
                    },
                    {
                        "article": "topological-sort",
                        "title": "Topological Sort",
                        "url": "/topological-sort",
                        "description": "Learn about Topological Sort, an algorithm for the linear ordering of vertices in a graph such that for all edges (u, v), u comes before v."
                    },
                    {
                        "article": "kahns-topological-sort-algorithm",
                        "title": "Kahn's Topological Sort Algorithm",
                        "url": "/kahns-topological-sort-algorithm",
                        "description": "Learn about Kahn's Topological Sort Algorithm, an algorithm for the topological ordering of a directed graph, by using depth first search."
                    },
                    {
                        "article": "strongly-connected-components",
                        "title": "Strongly Connected Components",
                        "url": "/strongly-connected-components",
                        "description": "Learn about Strongly Connected Components, a property such that there exists a path from any vertex to every other vertex in a subgraph."
                    },
                    {
                        "article": "kosarajus-algorithm",
                        "title": "Kosaraju's Algorithm",
                        "url": "/kosarajus-algorithm",
                        "description": "Learn about Kosaraju's Algorithm, an algorithm used for determining strongly connected components, by topological sorting and then using depth first search."
                    },
                    {
                        "article": "weighted-graph",
                        "title": "Weighted Graph",
                        "url": "/weighted-graph",
                        "description": "Learn about Weighted Graphs, which are graphs such that the edges are given a numerical weight, which may represent length, cost, or capacity."
                    },
                    {
                        "article": "cycle-detection",
                        "title": "Cycle Detection",
                        "url": "/cycle-detection",
                        "description": "Learn about Cycle Detection, which is the problem of determining the start and length of cycles within an graph, circular Linked list, or iterated function."
                    },
                    {
                        "article": "floyds-algorithm",
                        "title": "Floyd's Algorithm",
                        "url": "/floyds-algorithm",
                        "description": "Learn about Floyd's Algorithm, which is a cycle detection algorithm that works by using two pointers that traverse the graph at different speeds."
                    },
                    {
                        "article": "brents-algorithm",
                        "title": "Brent's Algorithm",
                        "url": "/brents-algorithm",
                        "description": "Learn about Brent's Algorithm, which is a cycle detection algorithm that is an improvement over Floyd's Algorithm, but it uses exponential search."
                    },
                    {
                        "article": "shortest-path-finding",
                        "title": "Shortest Path Finding",
                        "url": "/shortest-path-finding",
                        "description": "Learn about Shortest Path Finding, which is a fundamental problem in graph theory of being able to find the path from one vertex to another with the least combined weight."
                    },
                    {
                        "article": "edge-relaxation",
                        "title": "Edge Relaxation",
                        "url": "/edge-relaxation",
                        "description": "Learn about Edge Relaxation, which is a common operation used in shortest path finding algorithms, that is used to lower the cost of reaching a vertex by using another vertex."
                    },
                    {
                        "article": "dijkstras-algorithm",
                        "title": "Dijkstra's Algorithm",
                        "url": "/dijkstras-algorithm",
                        "description": "Learn about Dijkstra's Algorithm, a shortest path finding algorithm that is efficient for finding shortest paths in a graph with non-negative edge weights."
                    },
                    {
                        "article": "a-star-algorithm",
                        "title": "A* Algorithm",
                        "url": "/a-star-algorithm",
                        "description": "Learn about the A* Algorithm, a shortest path finding algorithm that uses heuristics to achieve a more efficient, directed search."
                    },
                    {
                        "article": "bellman-ford-algorithm",
                        "title": "Bellman-Ford Algorithm",
                        "url": "/bellman-ford-algorithm",
                        "description": "Learn about the Bellman-Ford Algorithm, a shortest path finding algorithm that is used for finding shortest paths with potentially negative edge weights."
                    },
                    {
                        "article": "floyd-warshall-algorithm",
                        "title": "Floyd-Warshall Algorithm",
                        "url": "/floyd-warshall-algorithm",
                        "description": "Learn about the Floyd-Warshall Algorithm, a shortest path finding algorithm that is used for finding shortest paths with negative edge weights by using dynamic programming."
                    },
                    {
                        "article": "greedy-algorithm",
                        "title": "Greedy Algorithm",
                        "url": "/greedy-algorithm",
                        "description": "Learn about Greedy Algorithms, a class of algorithms with the property of always choosing the locally optimal choice with the goal of achieving a globally optimal solution."
                    },
                    {
                        "article": "minimum-spanning-tree",
                        "title": "Minimum Spanning Tree",
                        "url": "/minimum-spanning-tree",
                        "description": "Learn about Minimum Spanning Trees, which are a set of edges of a graph such that they connect all of the vertices with no cycles between them."
                    },
                    {
                        "article": "prims-algorithm",
                        "title": "Prim's Algorithm",
                        "url": "/prims-algorithm",
                        "description": "Learn about Prim's Algorithm, an algorithm for finding the minimum spanning tree by always choosing the next least weight edge from the current minimum spanning tree."
                    },
                    {
                        "article": "kruskals-algorithm",
                        "title": "Kruskal's Algorithm",
                        "url": "/kruskals-algorithm",
                        "description": "Learn about Kruskal's Algorithm, an algorithm for finding the minimum spanning tree by always choosing the next least weight edge overall such that no cycles are formed."
                    },
                    {
                        "article": "network-flow",
                        "title": "Network Flow",
                        "url": "/network-flow",
                        "description": "Learn about Network Flow, a type of graph such that all edges have capacities, and recieve flows, and the flow cannot exceed the capacity."
                    },
                    {
                        "article": "max-flow-min-cut",
                        "title": "Max Flow Min Cut",
                        "url": "/max-flow-min-cut",
                        "description": "Learn about Max Flow Min Cut, a concept in network flow that states the max flow from the source to sink is equal to the total weight fo the edges in the min cut."
                    },
                    {
                        "article": "ford-fulkerson-algorithm",
                        "title": "Ford-Fulkerson Algorithm",
                        "url": "/ford-fulkerson-algorithm",
                        "description": "Learn about the Ford-Fulkerson Algorithm, an algorithm for finding the max flow within a flow network by greedily augmenting paths."
                    },
                    {
                        "article": "time-and-space-complexity",
                        "title": "Time and Space Complexity",
                        "url": "/time-and-space-complexity",
                        "description": "Learn about the time and space complexity of fundamental operations between the algorithms listed in this topic."                                                                        
                    }
                ]
            }
        ]
    },
    {
        "category": "paradigms",
        "title": "Paradigms",
        "url": "/categories/paradigms",
        "topics": [
            {
                "topic": "object-oriented-programming",
                "title": "Object Oriented Programming",
                "url": "/object-oriented-programming",
                "description": "Learn about object oriented programming concepts like encapsulation, inheritance, and polymorphism.",                        
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of the motivations behind object oriented programming, terminology and concepts that will be covered in this topic."
                    },
                    {
                        "article": "class-and-instance",
                        "title": "Class and Instance",
                        "url": "/class-and-instance",
                        "description": "Learn about Classes and Instances, which are are structures for a template of creating Objects, and concrete occurences of that Object."
                    },
                    {
                        "article": "inheritance",
                        "title": "Inheritance",
                        "url": "/inheritance",
                        "description": "Learn about Inheritance, which is when an Object of a particular class is able to acquire all of the properties, methods and functions of its parent class."
                    },
                    {
                        "article": "encapsulation",
                        "title": "Encapsulation",
                        "url": "/encapsulation",
                        "description": "Learn about Encapsulation, which is a property of Objects to be able to restrict access to its internal fields, methods and functions."
                    },
                    {
                        "article": "polymorphism",
                        "title": "Polymorphism",
                        "url": "/polymorphism",
                        "description": "Learn about Polymorphism, which is the mechanism of being able to use some abstract interface to apply to multiple classes that implement that interface."
                    }
                ]
            },
            {
                "topic": "functional-programming",
                "title": "Functional Programming",
                "url": "/functional-programming",
                "description": "Learn about functional programming concepts like lambda notation, function composition, filter, map, and reduce.",                
                "articles": [
                    {
                        "article": "introduction",
                        "title": "Introduction",
                        "url": "/introduction",
                        "description": "General overview of the motivations behind functional programming, terminology and concepts that will be covered in this topic."                        
                    },
                    {
                        "article": "first-class-function",
                        "title": "First Class Function",
                        "url": "/first-class-function",
                        "description": "Learn about the First Class Function, which is a property of functional programming languages where functions can be passed as arguments to other functions."
                    },
                    {
                        "article": "recursion",
                        "title": "Recursion",
                        "url": "/recursion",
                        "description": "Learn about Recursion, a programming method and general mechanism in functional programming, where solutions to problems depend on smaller subproblems."
                    },
                    {
                        "article": "lambda-notation",
                        "title": "Lambda Notation",
                        "url": "/lambda-notation",
                        "description": "Learn about Lambda Notation, a system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution."
                    },
                    {
                        "article": "functional-composition",
                        "title": "Function Composition",
                        "url": "/functional-composition",
                        "description": "Learn about Function Composition, a technique in functional programming for applying functions to the result of another function to produce a third function."
                    },
                    {
                        "article": "map-filter-reduce",
                        "title": "Map, Filter, Reduce",
                        "url": "/map-filter-reduce",
                        "description": "Learn about Map, Filter, and Reduce, which are fundamental functions that operate on lists of elements, and are used to augment, remove, and combine elements."
                    },
                    {
                        "article": "currying",
                        "title": "Currying",
                        "url": "/currying",
                        "description": "Learn about Currying, a technique in functional programming to translate the evaluation of a function with multiple arguments into a evaluating a sequence of functions."
                    }
                ]
            }
        ]
    }
]